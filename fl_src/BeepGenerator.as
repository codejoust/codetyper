package {	import flash.media.Sound;	import flash.media.SoundChannel;	import flash.media.SoundTransform;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.SampleDataEvent;	import flash.utils.ByteArray;	// A big mess! Oh well, it kind-of works. There's always more to do.	// Bear with me as this is my first sound-related and flash project	public class BeepGenerator {		private var beepSound:Sound;		private var soundChannel:SoundChannel;		private var soundBytes:ByteArray = new ByteArray();		private var vol:SoundTransform = new SoundTransform(0.5, 0);		public function BeepGenerator() {			//		}				private function addSoundBytesToSound(event:SampleDataEvent):void {			var bytes:ByteArray = new ByteArray(); // Clears buffer to sound object			soundBytes.readBytes(bytes, 0, Math.min(soundBytes.bytesAvailable, 8 * 8192));			event.data.writeBytes(bytes, 0, bytes.length); 		}		private function soundCompeleteHandler(event:Event):void {			// pass. nothing to see here.		}		public function stop():void {			soundChannel.stop();		}		private function initEngine():void {			if (soundChannel){ soundChannel.stop(); }			beepSound = new Sound();			beepSound.addEventListener(SampleDataEvent.SAMPLE_DATA, addSoundBytesToSound);			soundBytes.clear();		}		public function sendBippity():void {			initEngine();			soundBytes.writeBytes(silenceGenerator(Math.floor(Math.random() * 4)));			soundBytes.writeBytes(sineWaveGenerator());			soundBytes.writeBytes(addSin());			soundBytes.writeBytes(silenceGenerator(Math.floor(Math.random() * 8)));			soundBytes.writeBytes(addSin());			soundBytes.writeBytes(sineWaveGenerator2());			soundBytes.position = 0;			soundChannel = beepSound.play(0, 0, vol);		}		private function silenceGenerator(time:Number):ByteArray {			var returnBytes:ByteArray = new ByteArray();			for (var i:int = 0; i < time * 2400; i++){				returnBytes.writeFloat(0);				returnBytes.writeFloat(0);			}			return returnBytes;		}		private function sineWaveGenerator():ByteArray {			var alen:int = Math.floor(Math.random()*10);			var returnBytes:ByteArray = new ByteArray();			for ( var i:int = 0; i < length * 4400; i++ ) 			{				var value:Number = Math.sin(i / 6) * Math.floor((Math.random()*200)/200);				returnBytes.writeFloat(value);				returnBytes.writeFloat(value);			}			return returnBytes;		}		private function sineWaveGenerator2():ByteArray {			var alen:int = Math.floor(Math.random()*10);			var returnBytes:ByteArray = new ByteArray();			for ( var i:int = 0; i < length * 2400; i++ ) 			{				var value:Number = Math.sin(i / 4) * Math.floor((Math.random()*100)/200);				returnBytes.writeFloat(value);				returnBytes.writeFloat(value);			}			return returnBytes;		}		function addSin():ByteArray {			soundBytes = new ByteArray();			const SIZE:uint = Math.floor(Math.random()*2400) + 800;			for (var i:uint=0;i<SIZE;i++)			{				var wavePos:Number = 200*(2*Math.PI*i/SIZE);				var amplitude:Number = Math.sin(wavePos);				amplitude += Math.sin(wavePos*2)/4;				soundBytes.writeFloat(amplitude);				soundBytes.writeFloat(amplitude);				soundBytes.writeFloat(amplitude);				soundBytes.writeFloat(amplitude);			}			return soundBytes;		}		public function PlayStartup():void {			/*soundBytes.writeBytes(addSin());			soundBytes.writeBytes(addSin());			soundBytes.position = 0;*/			// Not used anymore.		}	}}